module ~{moduleName m}.~{handlerModuleName} where
import ~{moduleName m}.DB
import Prelude
import YesodDsl
import Data.Argonaut.Encode (class EncodeJson, encodeJson)
import Data.Argonaut.Decode (class DecodeJson, decodeJson)
import Data.Argonaut.Combinators ((~>), (:=), (.?))
import Data.Argonaut.Parser (jsonParser)
import Data.Argonaut.Core (jsonEmptyObject, Json)
import Control.Monad.Aff as Aff
import Network.HTTP.Affjax as Affjax
import Network.HTTP.RequestHeader as RH
import Network.HTTP.Method (Method(POST, PUT, DELETE))
import Network.HTTP.StatusCode as SC
import Data.Either (Either(..))
import Data.Maybe (Maybe(Just))

~{defineResultType}

newtype Params = Params {
~{indent 4 $ intercalate ",\n" $ map inputField $ handlerInputFields h}}

instance encodeJsonParams :: EncodeJson Params where
    encodeJson (Params x) = do
~{indent 8 $ intercalate "\n~> " $ map encodeJson $ handlerInputFields h}        ~> jsonEmptyObject

~{lowerFirst handlerTypeName} :: forall e. Affjax.URL~{concatMap (prepend " -> ") $ map snd $ routePathParams r} -> Array RH.RequestHeader -> Params -> Aff.Aff (ajax :: Affjax.AJAX | e) (Either String ~{resultType})
~{lowerFirst handlerTypeName} baseUrl~{concatMap (prepend " ") $ map fst $ routePathParams r} headers content = do
    r <- Affjax.affjax $ Affjax.defaultRequest {
            method = ~{show $ handlerType h},
            url = baseUrl~{routePathUrl r},
            headers = headers,
            content = Just (show $ encodeJson content)
        }
~{indent 4 $ processResult}

